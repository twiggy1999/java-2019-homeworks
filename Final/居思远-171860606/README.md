# JAVA葫芦娃大作业

#### 最终实现界面：

![](https://github.com/jsy-ics/picture/blob/master/1577800428267.png)

![](https://github.com/jsy-ics/picture/blob/master/1577801278584.png)

![](https://github.com/jsy-ics/picture/blob/master/1577801322434.png)

按下开始游戏按钮开始战斗，葫芦娃阵营和蛇精阵营自动寻敌进行战斗。采用的寻敌算法为寻找最近的敌人进行移动。不同阵营的两方相遇时发生战斗，两者以一个概率决定生死。

我设定是老爷爷、蛇精和蝎子精一开始并不参与战斗，直到己方兵力全部牺牲才会开始主动寻敌战斗。（如葫芦娃全部牺牲后老爷爷才会开始主动寻敌。）此外，虽然死亡单位处会出现墓碑，但实际上墓碑仍相当于空地，可以在此战斗和通过。

初始界面可以选择两方的阵容，开始游戏后，直到战斗结束均可随时暂停和继续。战斗结束后显示哪方胜利的信息，并出现按键重置棋盘，回到战斗开始时的情况。

而文件读取功能由于在处理多线程序列时出现过多bug，最终未能实现。

#### 程序说明：

UML类图

![](https://github.com/jsy-ics/picture/blob/master/355435.png)

主要实现方法：

首先在start中完成各个类的初始化：为生物创建对象、一个生物创建一个线程，地图的实例化，不同阵营生物按照阵型放置到地图上。然后是界面上的按钮、图形和背景初始化和显示，设置行为。全部初始化完成后生物线程start，开始执行战斗。战斗结束后生物线程terminated。等再次开始战斗时重新创建新的线程。

多线程：每个生物作为一个线程，进行自己的寻敌和战斗程序。为了保证多线程之间的安全，采用synchronized关键字进行同步，限定每个线程对数据的修改（我的程序中是对地图信息的修改）。生物类的有关多线程的操作基本都写在重写的run里。

![](https://github.com/jsy-ics/picture/blob/master/1577803781348.png)

#### 课程相关：

关于面向对象的程序设计：封装、继承和多态

封装即是将对一类数据及对其的操作全部封装在一个类中，本次代码就是如此实现。例如有关生物的操作在生物类中，有关地图类的操作再地图类中。

继承是子类可以使用父类的数据和方法，并进行扩展。可以看到生物类、阵型类为基类保存了这些类的基本操作和数据结构，从而生出众多子类。

多态就是同一操作作用于不同的类的实例，将产生不同的执行结果。而在阵型的构造中以及实例化中，传入的生物类型不同而功能不同。

面向对象设计原则：

SRP 单一职责原则、OCP 开放封闭原则、LSP LISKOV替换法则、ISP 接口隔离原则、CARP 合成/聚合复用原则

异常处理：在事件处理、响应处采用try {} catch 进行异常处理

集合类型：根据反射机制，同一接口的不同实例化

泛型：本次代码中未使用到

注解：使用@Override - 检查该方法是否是重载方法。如果发现其父类，或者是引用的接口中并没有该方法时，会报编译错误。

输入输出：文件读取时用到。
