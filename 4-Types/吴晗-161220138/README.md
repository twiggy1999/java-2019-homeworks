# 面向对象
## 概念
* 角色 role 代表葫芦娃、妖精、爷爷等各种角色，所以相应地有葫芦娃、妖精、人类的子类。角色有一些属性，姓名如“大娃”、“蝎子精”，阵营属性，葫芦娃和人类属于正义阵营，妖精属于邪恶阵营，还有在棋盘中的位置行列。子类还有自己独特的属性，葫芦娃有自己的排行属性，妖精有本质属性（什么动物化成的妖精），人类有性别属性（无特别作用，只是反应不同角色的独特之处）
* 棋盘 chessboard 有行、列属性，还有role构成的二维数组，二维数组就映射着现实中的棋盘，每一个元素放置一个role，映射棋盘上的角色棋子。
* 阵型 阵型是一个抽象类，阵型包括长蛇阵、鹤翼阵、雁行阵等，每一种具体的阵型会将棋盘上的角色摆成固定模样，但父类阵型本身没有具体功能，所以写成抽象类，方法是抽象方法，由具体的阵型去各自实现
## 机制
* 角色 
1. 跳向指定位置：主要用于棋盘上角色初始化时需要随机放置角色，生成随机数后直接让角色到指定位置
2. 到达新的位置：从随机产生的位置走到阵型要求角色需要到达的位置的位移过程，把位移过程拆解成向上、向下、向左、向右的每一步，这些一小步是private方法以供自身调用。
3. 让路：到达指定位置的一个很大的难题是碰到其他角色挡住自己的路，我设置的机制是角色A被角色B挡住时，会向B发出询问能否让出这个位置而不是绕开B，B会接收到信号，根据A是否和自己同一阵营（妖精不会给葫芦娃让路）以及自己是否有空间给A让路而决定。需要做出改进的地方在于还没有一个很好的call_back算法，让给自己让路的角色依次正确返回
* 棋盘
1. 一个角色改变位置涉及棋盘中数据的变化，和角色本身位置的变化要一致
2. 棋盘的输出： 目前只是按照二维数组的方式格式化输出，阵型也能看出来，但效果并不是达到完美，下一步需要实现输出图形化的棋盘，有横线有竖线
* 泛型
泛型运用在chessboard类中，调用阵型类和其中的排列算法时，阵型和角色是参数化类型，可以对不同的阵型、不同的角色输入进行类型检查，同时运用泛型实现抽象
* 反射
反射运用于角色、棋盘、阵型实例的构造，通过构造器构造任意一个类的对象，并且调用这些对象的方法。可以在运行时进行类型检查，需要抛出一些异常
## 设计理念
这次实验就像是象棋，也像是自走棋游戏。角色在棋盘中自由地移动，最后排成有规则的阵列。角色是”活“的，移动是一步一步移动的，被挡住时也会像现实中一样请求对方让路。棋盘类是比较死板的，基本负责记录棋盘中数据的变化，并不会去干涉角色移动。阵型就近似于现实中的我们，去给角色（棋子）指定位置移动，也不会干涉角色具体怎么移动。
![image](https://github.com/wwuuhan/java-2019-homeworks/blob/master/4-Types/吴晗-161220138/plantUMLclass_homework4.png)
